---
title: Infrastructure
weight: 20
---

# Infrastructure

The planning data [infrastructure repository](https://github.com/digital-land/digital-land-infrastructure) contains
terraform configuration files that create the necessary services to deploy applications and background tasks for the
planning data system.

## Overview

<% plantuml("c4-context.puml") %>

## Deploying

#### Authentication

[aws-vault](https://github.com/99designs/aws-vault) is recommended to assume the correct role for deploying resources to
the AWS environments. This guide does not cover the correct configuration of aws-vault.

Once configured correctly all the following commands can be executed as follows.

```shell
aws-vault exec <profile> -- <command>
```

### An Existing Environment

To deploy updates to an existing environment first, clone the
[infrastructure repository](https://github.com/digital-land/digital-land-infrastructure)
`git clone git@github.com:digital-land/digital-land-infrastructure.git`.

Once cloned, run `make apply STAGE=<environment>` to deploy the updated infrastructure configuration.

### A New Environment

To deploy a new environment the following details are needed:

* Environment name
* Root domain name

First, clone the [infrastructure repository](https://github.com/digital-land/digital-land-infrastructure)
`git clone git@github.com:digital-land/digital-land-infrastructure.git`.

Once cloned, run `make new-environment STAGE=<environment> DOMAIN=<root domain>` to create the needed configuration
files. Commit the created files to the repository.

Run `make apply STAGE=<environment>` to deploy the new environment, do not worry about errors, this will fail the first
time you deploy a new environment.


## Configuration Changes

### Add a new application

To create a new application in the terraform configuration, you will need to know the following:

* The **GitHub repository** (under the [digital-land](https://github.com/digital-land) organisation) hosting the application code.
* The **subdomain** of `planning.data.gov.uk` that the application will run under.
* An estimate of the **memory usage** of the application.
* A list of the application **environment variables**.
* If the application needs access to the SQLite or MBTiles files generated by backgroun tasks.

Add a new section to `variables.tf` under `locals.application_defaults`, replacing attributes as required.

```hcl
<name> = {
  // The subdomain to serve the application from
  access = {
    domain = "<subdomain>"
  }
  // Any static environment variables
  environment = {
    PORT = 5000 // Defaults to 80
  }
  // The GitHub repository that hosts the application code
  github_repository = "<organisation>/<repository>"
  // Set to true if the GitHub repository contains both an
  // application and a background task.
  github_repository_dual = false
  // The application healthcheck path and timeout
  healthcheck = {
    endpoint = "/"
    timeout = "30"
  }
  // Minimum and maximum number of application instances
  // The auto-scaling configuration scales the initial
  // number on:
  //  - 60% CPU Utilisation
  //  - 80% Memory Utilisation
  instances = {
    minimum = 1
    maximum = 2
    initial = 1
  }
  // The resources needed per application instance
  resources = {
    memory      = 1024
    cpu_credits = 20
  }
}
```

* Add a new application block in `main_apps.tf`, replacing attributes as required.

```hcl
module "application_<name>" {
  source = "./modules/application"

  name                = "<name>"
  stage               = var.stage
  resource_prefix     = "${var.stage}-<name>"
  cluster             = module.cluster.cluster
  tags                = module.tags.computed
  environment         = merge(
    module.storage.environment,
    {
      ENVIRONMENT = var.stage
      PORT = 5000
    }
  )
  secrets             = merge(
    module.storage.secrets
  )
  github_repository   = local.applications["<name>"].github_repository
  github_repository_dual = local.applications["<name>"].github_repository_dual
  deployment_approval = var.deployment_approval
  healthcheck         = local.applications["<name>"].healthcheck
  instances           = local.applications["<name>"].instances
  resources           = local.applications["<name>"].resources
  volumes             = {
    datasets = merge(
      module.storage.files.datasets,
      {
          readonly = true
      }
    )
  }

  additional_permissions = merge(
    module.storage.permissions.efs_read
  )

  access = merge(local.applications["datasette"].access, {
    certificate_arn = module.domain.certificate_arn
    zone_id         = module.domain.zone_id
  })

  network = {
    mode            = "awsvpc"
    vpc_id          = module.network.vpc_id
    subnets         = module.network.subnet_public_ids
    security_groups = [module.network.security_group_public_id]
  }
}
```

* Run terraform apply
* Check that the service is running on the appropriate domain name
* Update the slackbot token at `/<environment>-<application>/notifications/slack-token` in SSM
* If configured with a GitHub repository add a deployment workflow to the repo

```yaml
name: Deploy
on:
  push:
    branches: [main]
jobs:
  deploy-<environment>:
    runs-on: ubuntu-latest
    env:
      DOCKER_REPO: ${{ secrets.DEPLOY_DOCKER_REPOSITORY }}
    environment: <environment>
    steps:
      - uses: actions/checkout@v3
      - id: vars
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      - run: |
          sudo apt-get update
          sudo apt-get install -y rsync
      - uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          aws-access-key-id: ${{ secrets.DEPLOY_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEPLOY_AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2
      - uses: aws-actions/amazon-ecr-login@v1
      - run: docker pull $DOCKER_REPO:latest
      - run: docker build -t $DOCKER_REPO:${{ steps.vars.outputs.sha_short }} .
      - run: docker tag $DOCKER_REPO:${{ steps.vars.outputs.sha_short }} $DOCKER_REPO:latest
      - run: docker push $DOCKER_REPO:${{ steps.vars.outputs.sha_short }}
      - run: docker push $DOCKER_REPO:latest
```

### Add a new background task

